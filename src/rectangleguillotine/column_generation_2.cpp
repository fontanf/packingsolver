#include "rectangleguillotine/column_generation_2.hpp"

#include "packingsolver/rectangleguillotine/algorithm_formatter.hpp"
#include "rectangleguillotine/instance_flipper.hpp"
#include "rectangleguillotine/solution_builder.hpp"

#include "packingsolver/onedimensional/instance_builder.hpp"
#include "packingsolver/onedimensional/optimize.hpp"

#include "columngenerationsolver/algorithms/limited_discrepancy_search.hpp"

#include <thread>

using namespace packingsolver;
using namespace packingsolver::rectangleguillotine;

namespace
{

using Value = columngenerationsolver::Value;
using Column = columngenerationsolver::Column;
using PricingOutput = columngenerationsolver::PricingSolver::PricingOutput;

class ColumnGenerationPricingSolver: public columngenerationsolver::PricingSolver
{

public:

    ColumnGenerationPricingSolver(
            const Instance& instance):
        instance_(instance),
        filled_demands_(instance.number_of_item_types())
    { }

    virtual std::vector<std::shared_ptr<const Column>> initialize_pricing(
            const std::vector<std::pair<std::shared_ptr<const Column>, Value>>& fixed_columns);

    virtual PricingOutput solve_pricing(
            const std::vector<Value>& duals);

    void set_all_columns_2e_patterns_generated() { all_columns_2e_patterns_generated_ = true; }

    void set_all_columns_2n_patterns_generated() { all_columns_2n_patterns_generated_ = true; }

    void set_all_columns_2r_patterns_generated() { all_columns_2r_patterns_generated_ = true; }

    void set_all_columns_3h_patterns_generated() { all_columns_3h_patterns_generated_ = true; }

private:

    void generate_1e_patterns(
            const std::vector<Value>& duals,
            PricingOutput& output,
            Value& reduced_cost_bound);

    void generate_1n_patterns(
            const std::vector<Value>& duals,
            PricingOutput& output,
            Value& reduced_cost_bound);

    void generate_1ro_patterns(
            const std::vector<Value>& duals,
            PricingOutput& output,
            Value& reduced_cost_bound);

    void generate_2ho_patterns(
            const std::vector<Value>& duals,
            PricingOutput& output,
            Value& reduced_cost_bound);

    void generate_lower_stage_patterns(
            const std::vector<Value>& duals,
            PricingOutput& output,
            Value& reduced_cost_bound);

    const Instance& instance_;

    std::vector<ItemPos> filled_demands_;

    Length filled_width_ = 0;

    bool all_columns_2e_patterns_generated_ = false;

    bool all_columns_2n_patterns_generated_ = false;

    bool all_columns_2r_patterns_generated_ = false;

    bool all_columns_3h_patterns_generated_ = false;

};

Column solution_to_column(
        const Solution& solution)
{
    //solution.format(std::cout, 3);
    const Instance& instance = solution.instance();
    const BinType& bin_type = instance.bin_type(0);
    double multiplier_length = largest_power_of_two_lesser_or_equal(bin_type.rect.w);
    double multiplier_profit = largest_power_of_two_lesser_or_equal(instance.largest_item_profit());
    Length cut_thickness = instance.parameters().cut_thickness;

    Column column;
    for (ItemTypeId item_type_id = 0;
            item_type_id < instance.number_of_item_types();
            ++item_type_id) {
        const ItemType& item_type = instance.item_type(item_type_id);

        ItemPos copies = solution.item_copies(item_type_id);
        if (copies == 0)
            continue;

        if (instance.objective() == Objective::Knapsack)
            column.objective_coefficient += copies * item_type.profit / multiplier_profit;

        columngenerationsolver::LinearTerm element;
        element.row = item_type_id;
        element.coefficient = copies;
        column.elements.push_back(element);
    }
    Length width = solution.width() - bin_type.left_trim;
    if (instance.objective() == Objective::OpenDimensionX) {
        column.objective_coefficient = (double)(width + cut_thickness) / multiplier_length;
    } else {
        columngenerationsolver::LinearTerm element;
        element.row = instance.number_of_item_types();
        element.coefficient = (double)(width + cut_thickness) / multiplier_length;
        column.elements.push_back(element);
    }
    column.extra = std::shared_ptr<void>(new Solution(solution));

    //std::cout << column << std::endl;
    return column;
}

/**
 * Generate all columns for 1-staged roadef2018 patterns.
 *
 * When all items are oriented, 2-staged roadef2018 patterns can be generated by
 * solving a 0-1 knapsack problem. However, when some items might be rotated,
 * that doesn't hold anymore. In this case, we solve the Dantzig-Wolfe model of
 * the problem instead. Since the number of possible columns is small, we
 * generate them all at the beginning instead of using a column generation
 * scheme.
 */
std::vector<std::shared_ptr<const Column>> generate_all_columns_1r_patterns(
        const Instance& instance)
{
    const BinType& bin_type = instance.bin_type(0);

    std::vector<std::shared_ptr<const Column>> columns;

    // Sort item types by width.
    std::vector<std::pair<ItemTypeId, bool>> sorted_item_type_ids;
    for (ItemTypeId item_type_id = 0;
            item_type_id < instance.number_of_item_types();
            ++item_type_id) {
        const ItemType& item_type = instance.item_type(item_type_id);
        sorted_item_type_ids.push_back({item_type_id, false});
        if (!item_type.oriented)
            sorted_item_type_ids.push_back({item_type_id, true});
    }
    std::sort(
            sorted_item_type_ids.begin(),
            sorted_item_type_ids.end(),
            [&instance](
                const std::pair<ItemTypeId, bool>& p1,
                const std::pair<ItemTypeId, bool>& p2)
            {
                Length width_1 = (!p1.second)?
                    instance.item_type(p1.first).rect.w:
                    instance.item_type(p1.first).rect.h;
                Length width_2 = (!p2.second)?
                    instance.item_type(p2.first).rect.w:
                    instance.item_type(p2.first).rect.h;
                return width_1 < width_2;
            });
    for (ItemPos pos_1 = 0;
            pos_1 < (ItemPos)sorted_item_type_ids.size();
            ++pos_1) {
        ItemTypeId item_type_id_1 = sorted_item_type_ids[pos_1].first;
        const ItemType& item_type_1 = instance.item_type(item_type_id_1);
        Length width_1 = (!sorted_item_type_ids[pos_1].second)?
            item_type_1.rect.w:
            item_type_1.rect.h;
        Length height_1 = (!sorted_item_type_ids[pos_1].second)?
            item_type_1.rect.h:
            item_type_1.rect.w;

        if (height_1 > bin_type.rect.h)
            continue;

        // Retrieve strip.
        SolutionBuilder extra_solution_builder(instance);
        extra_solution_builder.add_bin(0, 1, CutOrientation::Vertical);
        extra_solution_builder.add_node(1, bin_type.left_trim + width_1);
        extra_solution_builder.add_node(2, bin_type.bottom_trim + height_1);
        extra_solution_builder.set_last_node_item(item_type_id_1);
        Solution extra_solution = extra_solution_builder.build();

        // Build column.
        Column column = solution_to_column(extra_solution);
        columns.push_back(std::shared_ptr<const Column>(new Column(column)));

        for (ItemPos pos_2 = pos_1;
                pos_2 < (ItemPos)sorted_item_type_ids.size();
                ++pos_2) {
            ItemTypeId item_type_id_2 = sorted_item_type_ids[pos_2].first;
            const ItemType& item_type_2 = instance.item_type(item_type_id_2);
            Length width_2 = (!sorted_item_type_ids[pos_2].second)?
                item_type_2.rect.w:
                item_type_2.rect.h;
            Length height_2 = (!sorted_item_type_ids[pos_2].second)?
                item_type_2.rect.h:
                item_type_2.rect.w;

            if (width_1 != width_2)
                break;
            if (item_type_id_1 == item_type_id_2
                    && item_type_1.copies == 1) {
                continue;
            }
            if (bin_type.bottom_trim
                    + height_1
                    + instance.parameters().cut_thickness
                    + height_2
                    + bin_type.top_trim
                    != bin_type.rect.h)
                continue;

            // Retrieve strip.
            SolutionBuilder extra_solution_builder(instance);
            extra_solution_builder.add_bin(0, 1, CutOrientation::Vertical);
            extra_solution_builder.add_node(1, bin_type.left_trim + width_1);
            extra_solution_builder.add_node(2, bin_type.bottom_trim + height_1);
            extra_solution_builder.set_last_node_item(item_type_id_1);
            extra_solution_builder.add_node(2, bin_type.bottom_trim + height_1 + instance.parameters().cut_thickness + height_2);
            extra_solution_builder.set_last_node_item(item_type_id_2);
            Solution extra_solution = extra_solution_builder.build();

            // Build column.
            Column column = solution_to_column(extra_solution);
            columns.push_back(std::shared_ptr<const Column>(new Column(column)));
        }
    }

    return columns;
}

/**
 * Generate all columns for 2-staged homogenous patterns.
 *
 * When all items are oriented, 3-staged homogenous patterns can be generated by
 * solving a 0-1 knapsack problem. However, when some items might be rotated,
 * that doesn't hold anymore. In this case, we solve the Dantzig-Wolfe model of
 * the problem instead. Since the number of possible columns is small, we
 * generate them all at the beginning instead of using a column generation
 * scheme.
 */
std::vector<std::shared_ptr<const Column>> generate_all_columns_2h_patterns(
        const Instance& instance)
{
    //std::cout << "generate_2hr_patterns..." << std::endl;
    const BinType& bin_type = instance.bin_type(0);

    std::vector<std::shared_ptr<const Column>> columns;

    // Sort item types by width.
    for (ItemTypeId item_type_id = 0;
            item_type_id < instance.number_of_item_types();
            ++item_type_id) {
        const ItemType& item_type = instance.item_type(item_type_id);
        //std::cout << "item_type_id " << item_type_id
        //    << " h " << item_type.rect.h << std::endl;

        ItemPos copies_max = (bin_type.rect.h - bin_type.bottom_trim - bin_type.top_trim + instance.parameters().cut_thickness)
            / (item_type.rect.h + instance.parameters().cut_thickness);
        //std::cout
        //    << "bin_type.h " << bin_type.rect.h
        //    << " copies_max " << copies_max
        //    << std::endl;
        for (ItemPos copies = 1; copies <= copies_max; ++copies) {

            // Build strip.
            //std::cout << "build strip no rotation..." << std::endl;
            //std::cout << "copies " << copies << std::endl;
            SolutionBuilder extra_solution_builder(instance);
            extra_solution_builder.add_bin(0, 1, CutOrientation::Vertical);
            //std::cout << "add_node 1 " << bin_type.left_trim + item_type.rect.w << std::endl;
            extra_solution_builder.add_node(1, bin_type.left_trim + item_type.rect.w);
            Length cut_position = bin_type.bottom_trim;
            for (ItemPos copy = 0; copy < copies; ++copy) {
                cut_position += item_type.rect.h;
                //std::cout << "add_node 2 " << cut_position << std::endl;
                extra_solution_builder.add_node(2, cut_position);
                extra_solution_builder.set_last_node_item(item_type_id);
                cut_position += instance.parameters().cut_thickness;
            }
            Solution extra_solution = extra_solution_builder.build();

            // Build column.
            Column column = solution_to_column(extra_solution);
            columns.push_back(std::shared_ptr<const Column>(new Column(column)));
        }

        if (!item_type.oriented) {
            ItemPos copies_max = (bin_type.rect.h - bin_type.bottom_trim - bin_type.top_trim + instance.parameters().cut_thickness)
                / (item_type.rect.w + instance.parameters().cut_thickness);
            for (ItemPos copies = 1; copies <= copies_max; ++copies) {

                // Build strip.
                //std::cout << "build strip rotation..." << std::endl;
                SolutionBuilder extra_solution_builder(instance);
                extra_solution_builder.add_bin(0, 1, CutOrientation::Vertical);
                extra_solution_builder.add_node(1, bin_type.left_trim + item_type.rect.h);
                Length cut_position = bin_type.bottom_trim;
                for (ItemPos copy = 0; copy < copies; ++copy) {
                    cut_position += item_type.rect.w;
                    extra_solution_builder.add_node(2, cut_position);
                    extra_solution_builder.set_last_node_item(item_type_id);
                    cut_position += instance.parameters().cut_thickness;
                }
                Solution extra_solution = extra_solution_builder.build();

                // Build column.
                Column column = solution_to_column(extra_solution);
                columns.push_back(std::shared_ptr<const Column>(new Column(column)));
            }
        }
    }

    //std::cout << "generate_2hr_patterns end" << std::endl;
    return columns;
}

/**
 * Generate all columns for 2-staged exact patterns.
 *
 * Stop if too many columns are generated.
 */
std::vector<std::shared_ptr<const Column>> generate_all_columns_2e_patterns(
        const Instance& instance)
{
    // TODO
    return {};
}

/**
 * Generate all columns for 2-staged non-exact patterns.
 *
 * Stop if too many columns are generated.
 */
std::vector<std::shared_ptr<const Column>> generate_all_columns_2n_patterns(
        const Instance& instance)
{
    // TODO
    return {};
}

/**
 * Generate all columns for 2-staged roadef2018 patterns.
 *
 * Stop if too many columns are generated.
 */
std::vector<std::shared_ptr<const Column>> generate_all_columns_2r_patterns(
        const Instance& instance)
{
    // TODO
    return {};
}

/**
 * Generate all columns for 3-staged homogenous patterns.
 *
 * Stop if too many patterns are generated.
 */
std::vector<std::shared_ptr<const Column>> generate_all_columns_3h_patterns(
        const Instance& instance)
{
    // TODO
    return {};
}

struct GetModelOutput
{
    columngenerationsolver::Model model;
    std::vector<std::shared_ptr<const Column>> column_pool;
};

GetModelOutput get_model(
        const Instance& instance)
{
    const BinType& bin_type = instance.bin_type(0);
    double multiplier_length = largest_power_of_two_lesser_or_equal(bin_type.rect.w);

    GetModelOutput output;
    columngenerationsolver::Model& model = output.model;
    std::vector<std::shared_ptr<const Column>>& column_pool = output.column_pool;

    if (instance.objective() == Objective::OpenDimensionX) {
        model.objective_sense = optimizationtools::ObjectiveDirection::Minimize;
    } else if (instance.objective() == Objective::Knapsack) {
        model.objective_sense = optimizationtools::ObjectiveDirection::Maximize;
    }

    // Row bounds.
    if (instance.objective() == Objective::Knapsack) {

        for (ItemTypeId item_type_id = 0;
                item_type_id < instance.number_of_item_types();
                ++item_type_id) {
            columngenerationsolver::Row row;
            row.lower_bound = 0;
            row.upper_bound = instance.item_type(item_type_id).copies;
            row.coefficient_lower_bound = 0;
            row.coefficient_upper_bound = instance.item_type(item_type_id).copies;
            model.rows.push_back(row);
        }

        columngenerationsolver::Row row;
        row.lower_bound = 0;
        row.upper_bound = (double)(bin_type.rect.w
            - bin_type.left_trim
            - bin_type.right_trim
            + instance.parameters().cut_thickness)
            / multiplier_length;
        row.coefficient_lower_bound = 0;
        row.coefficient_upper_bound = 1;
        model.rows.push_back(row);

    } else {
        for (ItemTypeId item_type_id = 0;
                item_type_id < instance.number_of_item_types();
                ++item_type_id) {
            columngenerationsolver::Row row;
            row.lower_bound = instance.item_type(item_type_id).copies;
            row.upper_bound = instance.item_type(item_type_id).copies;
            row.coefficient_lower_bound = 0;
            row.coefficient_upper_bound = instance.item_type(item_type_id).copies;
            model.rows.push_back(row);
        }
    }

    if (instance.parameters().number_of_stages == 1
            && instance.parameters().cut_type == CutType::Roadef2018) {
        for (const auto& column: generate_all_columns_1r_patterns(instance))
            column_pool.push_back(column);
    }
    if (instance.parameters().number_of_stages == 2
            && instance.parameters().cut_type == CutType::Homogenous) {
        for (const auto& column: generate_all_columns_2h_patterns(instance))
            column_pool.push_back(column);
    }

    // Pricing solver.
    model.pricing_solver = std::unique_ptr<columngenerationsolver::PricingSolver>(
            new ColumnGenerationPricingSolver(instance));

    // Try to generate all columns.

    if ((instance.parameters().number_of_stages == 2
                && instance.parameters().cut_type == CutType::Exact)
            || (instance.parameters().number_of_stages == 2
                && instance.parameters().cut_type == CutType::NonExact)
            || (instance.parameters().number_of_stages == 2
                && instance.parameters().cut_type == CutType::Roadef2018)
            || instance.parameters().number_of_stages >= 3) {
        auto columns = generate_all_columns_2e_patterns(instance);
        if (!columns.empty()) {
            for (const auto& column: columns)
                column_pool.push_back(column);
            static_cast<ColumnGenerationPricingSolver&>(*model.pricing_solver).set_all_columns_2e_patterns_generated();
        }
    }

    if ((instance.parameters().number_of_stages == 2
                && instance.parameters().cut_type == CutType::NonExact)
            || (instance.parameters().number_of_stages == 2
                && instance.parameters().cut_type == CutType::Roadef2018)
            || instance.parameters().number_of_stages >= 3) {
        auto columns = generate_all_columns_2n_patterns(instance);
        if (!columns.empty()) {
            for (const auto& column: columns)
                column_pool.push_back(column);
            static_cast<ColumnGenerationPricingSolver&>(*model.pricing_solver).set_all_columns_2n_patterns_generated();
        }
    }

    if (instance.parameters().number_of_stages == 2
            && instance.parameters().cut_type == CutType::Roadef2018
            && instance.all_item_types_oriented()) {
        auto columns = generate_all_columns_2r_patterns(instance);
        if (!columns.empty()) {
            for (const auto& column: columns)
                column_pool.push_back(column);
            static_cast<ColumnGenerationPricingSolver&>(*model.pricing_solver).set_all_columns_2r_patterns_generated();
        }
    }

    if (instance.parameters().number_of_stages >= 3) {
        auto columns = generate_all_columns_3h_patterns(instance);
        if (!columns.empty()) {
            for (const auto& column: columns)
                column_pool.push_back(column);
            static_cast<ColumnGenerationPricingSolver&>(*model.pricing_solver).set_all_columns_3h_patterns_generated();
        }
    }

    return output;
}

std::vector<std::shared_ptr<const Column>> ColumnGenerationPricingSolver::initialize_pricing(
        const std::vector<std::pair<std::shared_ptr<const Column>, Value>>& fixed_columns)
{
    //std::cout << "initialize_pricing " << fixed_columns.size() << std::endl;
    const BinType& bin_type = instance_.bin_type(0);
    double multiplier_length = largest_power_of_two_lesser_or_equal(bin_type.rect.w);
    std::fill(filled_demands_.begin(), filled_demands_.end(), 0);
    filled_width_ = 0;
    for (auto p: fixed_columns) {
        const Column& column = *(p.first);
        Value value = p.second;
        for (const columngenerationsolver::LinearTerm& element: column.elements) {
            if (element.row < instance_.number_of_item_types()) {
                ItemTypeId item_type_id = element.row;
                ItemPos copies = instance_.item_type(item_type_id).copies;
                filled_demands_[item_type_id] += std::round(value) * std::round(element.coefficient);
                if (filled_demands_[item_type_id] > copies) {
                    throw std::logic_error(
                            FUNC_SIGNATURE + "; "
                            "item_type_id: " + std::to_string(item_type_id) + "; "
                            "copies: " + std::to_string(copies) + "; "
                            "filled_demands: " + std::to_string(filled_demands_[item_type_id]) + ".");
                }
            } else {
                filled_width_ += std::round(value) * multiplier_length * element.coefficient;
            }
        }
    }
    //std::cout << "initialize_pricing end" << std::endl;
    return {};
}

void ColumnGenerationPricingSolver::generate_1e_patterns(
        const std::vector<Value>& duals,
        PricingOutput& output,
        Value& reduced_cost_bound)
{
    //std::cout << "generate_1e_patterns..." << std::endl;
    const BinType& bin_type = instance_.bin_type(0);
    double multiplier_profit = largest_power_of_two_lesser_or_equal(instance_.largest_item_profit());
    Length cut_thickness = instance_.parameters().cut_thickness;
    Length width = bin_type.rect.w - bin_type.left_trim - bin_type.right_trim - filled_width_;
    Length height = bin_type.rect.h - bin_type.bottom_trim - bin_type.top_trim;
    for (;;) {
        //std::cout << "1E width " << width << std::endl;

        // Build one-dimensional knapsack instance.
        onedimensional::InstanceBuilder kp_instance_builder;
        kp_instance_builder.set_objective(Objective::Knapsack);
        kp_instance_builder.add_bin_type(height + cut_thickness);
        std::vector<BinTypeId> kp2orig;
        for (ItemTypeId item_type_id = 0;
                item_type_id < instance_.number_of_item_types();
                ++item_type_id) {
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos copies = item_type.copies - filled_demands_[item_type_id];
            if (copies == 0)
                continue;

            Profit profit = 0;
            if (instance_.objective() == Objective::OpenDimensionX) {
                profit = duals[item_type_id];
            } else if (instance_.objective() == Objective::Knapsack) {
                profit = item_type.profit - duals[item_type_id] * multiplier_profit;
            }
            if (profit <= 0)
                continue;

            if (item_type.rect.w == width
                    && item_type.rect.h <= height) {
                kp_instance_builder.add_item_type(
                        item_type.rect.h + cut_thickness,
                        profit,
                        copies);
                kp2orig.push_back(item_type_id);
            } else if (!item_type.oriented
                    && item_type.rect.h == width
                    && item_type.rect.w <= height) {
                kp_instance_builder.add_item_type(
                        item_type.rect.w + cut_thickness,
                        profit,
                        copies);
                kp2orig.push_back(item_type_id);
            }
        }
        onedimensional::Instance kp_instance = kp_instance_builder.build();

        if (kp_instance.number_of_item_types() > 0) {

            // Solve one-dimensional knapsack problem.
            onedimensional::OptimizeParameters kp_parameters;
            kp_parameters.verbosity_level = 0;
            auto kp_output = optimize(kp_instance, kp_parameters);

            // Retrieve solution.
            SolutionBuilder extra_solution_builder(instance_);
            extra_solution_builder.add_bin(0, 1, CutOrientation::Vertical);
            extra_solution_builder.add_node(1, bin_type.left_trim + width);
            Length cut_position = bin_type.bottom_trim;
            for (ItemTypeId kp_item_type_id = 0;
                    kp_item_type_id < kp_instance.number_of_item_types();
                    ++kp_item_type_id) {
                ItemTypeId item_type_id = kp2orig[kp_item_type_id];
                const ItemType& item_type = instance_.item_type(item_type_id);

                ItemPos copies = kp_output.solution_pool.best().item_copies(kp_item_type_id);
                if (copies == 0)
                    continue;

                for (ItemPos copy = 0; copy < copies; ++copy) {
                    cut_position += (item_type.rect.w == width)?
                        item_type.rect.h:
                        item_type.rect.w;
                    extra_solution_builder.add_node(2, cut_position);
                    extra_solution_builder.set_last_node_item(item_type_id);
                    cut_position += cut_thickness;
                }
            }
            Solution extra_solution = extra_solution_builder.build();

            // Retrieve column.
            Column column = solution_to_column(extra_solution);
            output.columns.push_back(std::shared_ptr<const Column>(new Column(column)));
            if (instance_.parameters().number_of_stages == 3
                    && instance_.parameters().cut_type == CutType::Homogenous) {
                reduced_cost_bound = (std::max)(
                        reduced_cost_bound,
                        columngenerationsolver::compute_reduced_cost(column, duals));
            }

        }

        // Find the largest width strictly smaller than the largest width
        // in the generated column.
        Length width_new = 0;
        for (ItemTypeId item_type_id = 0;
                item_type_id < instance_.number_of_item_types();
                ++item_type_id) {
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos copies = item_type.copies - filled_demands_[item_type_id];
            if (copies == 0)
                continue;

            Profit profit = 0;
            if (instance_.objective() == Objective::OpenDimensionX) {
                profit = duals[item_type_id];
            } else if (instance_.objective() == Objective::Knapsack) {
                profit = item_type.profit - duals[item_type_id] * multiplier_profit;
            }
            if (profit <= 0)
                continue;

            if (item_type.rect.w < width
                    && item_type.rect.h <= height
                    && width_new < item_type.rect.w) {
                width_new = item_type.rect.w;
            }
            if (!item_type.oriented
                    && item_type.rect.h < width
                    && item_type.rect.w <= height
                    && width_new < item_type.rect.h) {
                width_new = item_type.rect.h;
            }
        }
        if (width_new == 0)
            break;
        width = width_new;
    }
    //std::cout << "generate_1e_patterns end" << std::endl;
}

void ColumnGenerationPricingSolver::generate_1n_patterns(
        const std::vector<Value>& duals,
        PricingOutput& output,
        Value& reduced_cost_bound)
{
    //std::cout << "generate_1n_patterns..." << std::endl;
    const BinType& bin_type = instance_.bin_type(0);
    double multiplier_profit = largest_power_of_two_lesser_or_equal(instance_.largest_item_profit());
    Length cut_thickness = instance_.parameters().cut_thickness;
    Length width = bin_type.rect.w - bin_type.left_trim - bin_type.right_trim - filled_width_;
    Length height = bin_type.rect.h - bin_type.bottom_trim - bin_type.top_trim;
    for (;;) {
        //std::cout << "1N width " << width << std::endl;

        // Build one-dimensional knapsack instance.
        onedimensional::InstanceBuilder kp_instance_builder;
        kp_instance_builder.set_objective(Objective::Knapsack);
        kp_instance_builder.add_bin_type(height + cut_thickness);
        std::vector<std::pair<ItemTypeId, Length>> kp2orig;
        for (ItemTypeId item_type_id = 0;
                item_type_id < instance_.number_of_item_types();
                ++item_type_id) {
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos copies = item_type.copies - filled_demands_[item_type_id];
            if (copies == 0)
                continue;

            Profit profit = 0;
            if (instance_.objective() == Objective::OpenDimensionX) {
                profit = duals[item_type_id];
            } else if (instance_.objective() == Objective::Knapsack) {
                profit = item_type.profit - duals[item_type_id] * multiplier_profit;
            }
            if (!strictly_greater(profit, 0.0))
                continue;

            Length item_width = width + 1;
            Length item_height = height + 1;
            if (item_type.rect.w <= width
                    && item_type.rect.h <= height) {
                item_width = item_type.rect.w;
                item_height = item_type.rect.h;
            }
            if (!item_type.oriented
                    && item_type.rect.h <= width
                    && item_type.rect.w <= height
                    && item_type.rect.w < item_height) {
                item_width = item_type.rect.h;
                item_height = item_type.rect.w;
            }

            if (item_width <= width) {
                kp_instance_builder.add_item_type(
                        item_height + cut_thickness,
                        profit,
                        copies);
                kp2orig.push_back({item_type_id, item_width});
            }
        }
        onedimensional::Instance kp_instance = kp_instance_builder.build();
        if (kp_instance.number_of_item_types() == 0)
            break;

        // Solve one-dimensional knapsack problem.
        onedimensional::OptimizeParameters kp_parameters;
        kp_parameters.verbosity_level = 0;
        auto kp_output = optimize(kp_instance, kp_parameters);

        // Retrieve width_max.
        Length width_max = 0;
        for (ItemTypeId kp_item_type_id = 0;
                kp_item_type_id < kp_instance.number_of_item_types();
                ++kp_item_type_id) {
            ItemTypeId item_type_id = kp2orig[kp_item_type_id].first;
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos copies = kp_output.solution_pool.best().item_copies(kp_item_type_id);
            if (copies == 0)
                continue;

            if (width_max < kp2orig[kp_item_type_id].second)
                width_max = kp2orig[kp_item_type_id].second;
        }

        // Retrieve solution.
        //std::cout << "build extra solution width_max " << width_max << std::endl;
        SolutionBuilder extra_solution_builder(instance_);
        extra_solution_builder.add_bin(0, 1, CutOrientation::Vertical);
        extra_solution_builder.add_node(1, bin_type.left_trim + width_max);
        Length cut_position = bin_type.bottom_trim;
        for (ItemTypeId kp_item_type_id = 0;
                kp_item_type_id < kp_instance.number_of_item_types();
                ++kp_item_type_id) {
            ItemTypeId item_type_id = kp2orig[kp_item_type_id].first;
            const ItemType& item_type = instance_.item_type(item_type_id);
            Length width_cur = kp2orig[kp_item_type_id].second;

            ItemPos copies = kp_output.solution_pool.best().item_copies(kp_item_type_id);
            if (copies == 0)
                continue;

            for (ItemPos copy = 0; copy < copies; ++copy) {
                cut_position += kp_instance.item_type(kp_item_type_id).length
                    - cut_thickness;
                extra_solution_builder.add_node(2, cut_position);
                if (width_cur < width_max)
                    extra_solution_builder.add_node(3, bin_type.left_trim + width_cur);
                extra_solution_builder.set_last_node_item(item_type_id);
                cut_position += cut_thickness;
            }
        }
        Solution extra_solution = extra_solution_builder.build();

        // Retrieve column.
        Column column = solution_to_column(extra_solution);
        output.columns.push_back(std::shared_ptr<const Column>(new Column(column)));
        if (instance_.parameters().number_of_stages == 2
                && instance_.parameters().cut_type == CutType::Exact) {
            reduced_cost_bound = (std::max)(
                    reduced_cost_bound,
                    columngenerationsolver::compute_reduced_cost(column, duals));
        }

        // Find the largest width strictly smaller than the largest width
        // in the generated column.
        Length width_new = 0;
        for (ItemTypeId item_type_id = 0;
                item_type_id < instance_.number_of_item_types();
                ++item_type_id) {
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos copies = item_type.copies - filled_demands_[item_type_id];
            if (copies == 0)
                continue;

            Profit profit = 0;
            if (instance_.objective() == Objective::OpenDimensionX) {
                profit = duals[item_type_id];
            } else if (instance_.objective() == Objective::Knapsack) {
                profit = item_type.profit - duals[item_type_id] * multiplier_profit;
            }
            if (!strictly_greater(profit, 0.0))
                continue;

            if (item_type.rect.w < width_max
                    && item_type.rect.h <= height
                    && width_new < item_type.rect.w) {
                width_new = item_type.rect.w;
            }
            if (!item_type.oriented
                    && item_type.rect.h < width_max
                    && item_type.rect.w <= height
                    && width_new < item_type.rect.h) {
                width_new = item_type.rect.h;
            }
        }
        if (width_new == 0)
            break;
        width = width_new;
    }
    //std::cout << "generate_1n_patterns end" << std::endl;
}

void ColumnGenerationPricingSolver::generate_1ro_patterns(
        const std::vector<Value>& duals,
        PricingOutput& output,
        Value& reduced_cost_bound)
{
    //std::cout << "generate_1ro_patterns..." << std::endl;
    const BinType& bin_type = instance_.bin_type(0);
    double multiplier_profit = largest_power_of_two_lesser_or_equal(instance_.largest_item_profit());
    Length cut_thickness = instance_.parameters().cut_thickness;
    Length width = bin_type.rect.w - bin_type.left_trim - bin_type.right_trim - filled_width_;
    Length height = bin_type.rect.h - bin_type.bottom_trim - bin_type.top_trim;

    // Sort items by height and then by profit.
    std::vector<std::pair<ItemTypeId, double>> sorted_item_type_ids;
    for (ItemTypeId item_type_id = 0;
            item_type_id < instance_.number_of_item_types();
            ++item_type_id) {
        const ItemType& item_type = instance_.item_type(item_type_id);
        ItemPos copies = item_type.copies - filled_demands_[item_type_id];
        if (copies == 0)
            continue;

        Profit profit = 0;
        if (instance_.objective() == Objective::OpenDimensionX) {
            profit = duals[item_type_id];
        } else if (instance_.objective() == Objective::Knapsack) {
            profit = item_type.profit - duals[item_type_id] * multiplier_profit;
        }
        if (!strictly_greater(profit, 0.0))
            continue;

        sorted_item_type_ids.push_back({item_type_id, profit});
    }
    std::sort(
            sorted_item_type_ids.begin(),
            sorted_item_type_ids.end(),
            [this](
                const std::pair<ItemTypeId, bool>& p1,
                const std::pair<ItemTypeId, bool>& p2)
            {
                const ItemType& item_type_1 = instance_.item_type(p1.first);
                const ItemType& item_type_2 = instance_.item_type(p2.first);
                if (item_type_1.rect.h != item_type_2.rect.h)
                    return item_type_1.rect.h < item_type_2.rect.h;
                return p1.second > p2.second;
            });
    //for (const auto& p: sorted_item_type_ids)
    //    std::cout << "item_type_id " << p.first << " profit " << p.second << std::endl;

    for (;;) {
        //std::cout << "2RO width " << width << std::endl;

        std::vector<ItemPos> remaining_copies(instance_.number_of_item_types(), 0);
        for (ItemTypeId item_type_id = 0;
                item_type_id < instance_.number_of_item_types();
                ++item_type_id) {
            const ItemType& item_type = instance_.item_type(item_type_id);
            ItemPos copies = item_type.copies - filled_demands_[item_type_id];
            if (copies == 0)
                continue;
            remaining_copies[item_type_id] = copies;
        }

        // Build one-dimensional knapsack instance.
        onedimensional::InstanceBuilder kp_instance_builder;
        kp_instance_builder.set_objective(Objective::Knapsack);
        kp_instance_builder.add_bin_type(height + cut_thickness);
        std::vector<std::pair<ItemTypeId, ItemTypeId>> kp2orig;
        for (ItemTypeId item_type_pos_1 = 0;
                item_type_pos_1 < (ItemTypeId)sorted_item_type_ids.size();
                ++item_type_pos_1) {
            ItemTypeId item_type_id_1 = sorted_item_type_ids[item_type_pos_1].first;
            Profit profit_1 = sorted_item_type_ids[item_type_pos_1].second;
            const ItemType& item_type_1 = instance_.item_type(item_type_id_1);
            if (item_type_1.rect.h > height)
                continue;
            if (item_type_1.rect.w > width)
                continue;

            for (ItemTypeId item_type_pos_2 = item_type_pos_1;
                    item_type_pos_2 < (ItemTypeId)sorted_item_type_ids.size();
                    ++item_type_pos_2) {
                ItemTypeId item_type_id_2 = sorted_item_type_ids[item_type_pos_2].first;
                const ItemType& item_type_2 = instance_.item_type(item_type_id_2);
                Profit profit_2 = sorted_item_type_ids[item_type_pos_2].second;

                // Items must be of the same height.
                if (item_type_2.rect.h != item_type_1.rect.h)
                    break;

                // The sum of their widths must match the strip width.
                if (item_type_1.rect.w
                        + cut_thickness
                        + item_type_2.rect.w
                        != width) {
                    continue;
                }

                if (item_type_id_1 == item_type_id_2
                        && remaining_copies[item_type_id_1] == 1)
                    continue;

                ItemPos copies = (item_type_id_1 == item_type_id_2)?
                    remaining_copies[item_type_id_1] / 2:
                    std::min(remaining_copies[item_type_id_1], remaining_copies[item_type_id_2]);
                if (copies == 0)
                    continue;

                //std::cout << "add_item_type " << item_type_id_1
                //    << " " << item_type_id_2
                //    << " profit " << profit_1 + profit_2
                //    << std::endl;
                kp_instance_builder.add_item_type(
                        item_type_1.rect.h + cut_thickness,
                        profit_1 + profit_2,
                        copies);
                kp2orig.push_back({item_type_id_1, item_type_id_2});

                remaining_copies[item_type_id_1] -= copies;
                remaining_copies[item_type_id_2] -= copies;
            }
            if (remaining_copies[item_type_id_1] > 0) {
                //std::cout << "add_item_type " << item_type_id_1 << std::endl;
                kp_instance_builder.add_item_type(
                        item_type_1.rect.h,
                        profit_1,
                        remaining_copies[item_type_id_1]);
                kp2orig.push_back({item_type_id_1, -1});
            }
        }
        onedimensional::Instance kp_instance = kp_instance_builder.build();
        if (kp_instance.number_of_item_types() == 0)
            break;

        // Solve one-dimensional knapsack problem.
        onedimensional::OptimizeParameters kp_parameters;
        kp_parameters.verbosity_level = 0;
        auto kp_output = optimize(kp_instance, kp_parameters);

        // Retrieve width_max.
        Length width_max = 0;
        for (ItemTypeId kp_item_type_id = 0;
                kp_item_type_id < kp_instance.number_of_item_types();
                ++kp_item_type_id) {
            ItemTypeId item_type_id_1 = kp2orig[kp_item_type_id].first;
            ItemTypeId item_type_id_2 = kp2orig[kp_item_type_id].second;

            ItemPos kp_copies = kp_output.solution_pool.best().item_copies(kp_item_type_id);
            if (kp_copies == 0)
                continue;

            const ItemType& item_type_1 = instance_.item_type(item_type_id_1);
            Length width_cur = item_type_1.rect.w;
            //std::cout << "kp_item_type_id " << kp_item_type_id
            //    << " kp_copies " << kp_copies
            //    << " item_type_id_1 " << item_type_id_1
            //    << " w " << item_type_1.rect.w
            //    << " item_type_id_2 " << item_type_id_2
            //    << std::endl;
            if (item_type_id_2 != -1) {
                const ItemType& item_type_2 = instance_.item_type(item_type_id_2);
                width_cur += cut_thickness + item_type_2.rect.w;
            }
            if (width_max < width_cur)
                width_max = width_cur;
        }

        // Build extra solution.
        //std::cout << "build extra solution width_max " << width_max << std::endl;
        SolutionBuilder extra_solution_builder(instance_);
        extra_solution_builder.add_bin(0, 1, CutOrientation::Vertical);
        extra_solution_builder.add_node(1, bin_type.left_trim + width_max);
        Length cut_position = bin_type.bottom_trim;
        for (ItemTypeId kp_item_type_id = 0;
                kp_item_type_id < kp_instance.number_of_item_types();
                ++kp_item_type_id) {
            ItemTypeId item_type_id_1 = kp2orig[kp_item_type_id].first;
            const ItemType& item_type_1 = instance_.item_type(item_type_id_1);

            ItemPos kp_copies = kp_output.solution_pool.best().item_copies(kp_item_type_id);
            if (kp_copies == 0)
                continue;

            for (ItemPos kp_copy = 0; kp_copy < kp_copies; ++kp_copy) {
                cut_position += item_type_1.rect.h;
                extra_solution_builder.add_node(2, cut_position);

                if (item_type_1.rect.w < width_max) {
                    extra_solution_builder.add_node(
                            3,
                            bin_type.left_trim
                            + item_type_1.rect.w);
                }
                extra_solution_builder.set_last_node_item(item_type_id_1);

                ItemTypeId item_type_id_2 = kp2orig[kp_item_type_id].second;
                if (item_type_id_2 != -1) {
                    const ItemType& item_type_2 = instance_.item_type(item_type_id_2);
                    extra_solution_builder.add_node(
                            3,
                            bin_type.left_trim
                            + item_type_1.rect.w
                            + cut_thickness
                            + item_type_2.rect.w);
                    extra_solution_builder.set_last_node_item(item_type_id_2);
                }
                cut_position += cut_thickness;
            }
        }
        Solution extra_solution = extra_solution_builder.build();

        // Retrieve column.
        Column column = solution_to_column(extra_solution);
        output.columns.push_back(std::shared_ptr<const Column>(new Column(column)));
        if (instance_.parameters().number_of_stages == 3
                && instance_.parameters().cut_type == CutType::Homogenous
                && instance_.all_item_types_oriented()) {
            reduced_cost_bound = (std::max)(
                    reduced_cost_bound,
                    columngenerationsolver::compute_reduced_cost(column, duals));
        }

        // Find the largest width strictly smaller than the largest width
        // in the generated column.
        Length width_new = 0;
        // If 'width_max < width', we may still needs to try with a new width of
        // 'width_max' since item pairs valid with width 'width_max' were not
        // valid with width 'width'.
        if (width_max < width)
            width_max++;
        for (ItemTypeId item_type_id = 0;
                item_type_id < instance_.number_of_item_types();
                ++item_type_id) {
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos copies = item_type.copies - filled_demands_[item_type_id];
            if (copies == 0)
                continue;

            Profit profit = 0;
            if (instance_.objective() == Objective::OpenDimensionX) {
                profit = duals[item_type_id];
            } else if (instance_.objective() == Objective::Knapsack) {
                profit = item_type.profit - duals[item_type_id] * multiplier_profit;
            }
            if (!strictly_greater(profit, 0.0))
                continue;

            ItemPos number_of_copies_in_full_strip = (width_max - 1) / item_type.rect.w;
            if (number_of_copies_in_full_strip == 0)
                continue;
            if (item_type.rect.h > height)
                continue;
            ItemPos number_of_full_strips = copies / number_of_copies_in_full_strip;
            ItemPos number_of_copies_in_last_strip = copies % number_of_copies_in_full_strip;
            Length width_cur = (number_of_full_strips > 0)?
                number_of_copies_in_full_strip * item_type.rect.w:
                number_of_copies_in_last_strip * item_type.rect.w;
            //std::cout << "wj " << item_type.rect.w
            //    << " copies " << copies
            //    << " number_of_copies_in_full_strip " << number_of_full_strips
            //    << " number_of_full_strips " << number_of_full_strips
            //    << " number_of_copies_in_last_strip " << number_of_copies_in_last_strip
            //    << " wcur " << width_cur
            //    << std::endl;

            if (width_cur < width_max
                    && width_new < width_cur) {
                width_new = width_cur;
            }
        }
        if (width_new == 0)
            break;
        width = width_new;
    }
    //std::cout << "generate_1ro_patterns end" << std::endl;
}

void ColumnGenerationPricingSolver::generate_2ho_patterns(
        const std::vector<Value>& duals,
        PricingOutput& output,
        Value& reduced_cost_bound)
{
    //std::cout << "generate_2ho_patterns..." << std::endl;
    const BinType& bin_type = instance_.bin_type(0);
    double multiplier_profit = largest_power_of_two_lesser_or_equal(instance_.largest_item_profit());
    Length cut_thickness = instance_.parameters().cut_thickness;
    Length width = bin_type.rect.w - bin_type.left_trim - bin_type.right_trim - filled_width_;
    Length height = bin_type.rect.h - bin_type.bottom_trim - bin_type.top_trim;
    for (;;) {
        //std::cout << "2HO width " << width << std::endl;

        // Build one-dimensional knapsack instance.
        onedimensional::InstanceBuilder kp_instance_builder;
        kp_instance_builder.set_objective(Objective::Knapsack);
        kp_instance_builder.add_bin_type(height + cut_thickness);
        std::vector<std::pair<ItemTypeId, ItemPos>> kp2orig;
        for (ItemTypeId item_type_id = 0;
                item_type_id < instance_.number_of_item_types();
                ++item_type_id) {
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos copies = item_type.copies - filled_demands_[item_type_id];
            if (copies == 0)
                continue;

            Profit profit = 0;
            if (instance_.objective() == Objective::OpenDimensionX) {
                profit = duals[item_type_id];
            } else if (instance_.objective() == Objective::Knapsack) {
                profit = item_type.profit - duals[item_type_id] * multiplier_profit;
            }
            if (!strictly_greater(profit, 0.0))
                continue;

            ItemPos number_of_copies_in_full_strip = (width + cut_thickness)
                / (item_type.rect.w + cut_thickness);
            if (number_of_copies_in_full_strip == 0)
                continue;
            if (item_type.rect.h > height)
                continue;
            ItemPos number_of_full_strips = copies / number_of_copies_in_full_strip;
            ItemPos number_of_copies_in_last_strip = copies % number_of_copies_in_full_strip;
            Length width_cur = (number_of_full_strips > 0)?
                number_of_copies_in_full_strip * item_type.rect.w
                + (number_of_copies_in_full_strip - 1) * cut_thickness:
                number_of_copies_in_last_strip * item_type.rect.w
                + (number_of_copies_in_last_strip - 1) * cut_thickness;
            //std::cout << "wj " << item_type.rect.w
            //    << " copies " << copies
            //    << " number_of_copies_in_full_strip " << number_of_copies_in_full_strip
            //    << " number_of_full_strips " << number_of_full_strips
            //    << " number_of_copies_in_last_strip " << number_of_copies_in_last_strip
            //    << " wcur " << width_cur
            //    << std::endl;

            if (number_of_full_strips > 0) {
                kp_instance_builder.add_item_type(
                        item_type.rect.h + cut_thickness,
                        number_of_copies_in_full_strip * profit,
                        number_of_full_strips);
                kp2orig.push_back({item_type_id, number_of_copies_in_full_strip});
            }
            if (number_of_copies_in_last_strip > 0) {
                kp_instance_builder.add_item_type(
                        item_type.rect.h + cut_thickness,
                        number_of_copies_in_last_strip * profit,
                        1);
                kp2orig.push_back({item_type_id, number_of_copies_in_last_strip});
            }
        }
        onedimensional::Instance kp_instance = kp_instance_builder.build();
        if (kp_instance.number_of_item_types() == 0)
            break;

        // Solve one-dimensional knapsack problem.
        onedimensional::OptimizeParameters kp_parameters;
        kp_parameters.verbosity_level = 0;
        auto kp_output = optimize(kp_instance, kp_parameters);

        // Retrieve width_max.
        Length width_max = 0;
        for (ItemTypeId kp_item_type_id = 0;
                kp_item_type_id < kp_instance.number_of_item_types();
                ++kp_item_type_id) {
            ItemTypeId item_type_id = kp2orig[kp_item_type_id].first;
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos kp_copies = kp_output.solution_pool.best().item_copies(kp_item_type_id);
            if (kp_copies == 0)
                continue;

            ItemPos copies = kp2orig[kp_item_type_id].second;
            Length width = item_type.rect.w * copies
                + cut_thickness * (copies - 1);
            if (width_max < width)
                width_max = width;
        }

        // Build extra solution.
        //std::cout << "build extra solution width_max " << width_max << std::endl;
        SolutionBuilder extra_solution_builder(instance_);
        extra_solution_builder.add_bin(0, 1, CutOrientation::Vertical);
        extra_solution_builder.add_node(1, bin_type.left_trim + width_max);
        Length cut_position = bin_type.bottom_trim;
        for (ItemTypeId kp_item_type_id = 0;
                kp_item_type_id < kp_instance.number_of_item_types();
                ++kp_item_type_id) {
            ItemTypeId item_type_id = kp2orig[kp_item_type_id].first;
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos kp_copies = kp_output.solution_pool.best().item_copies(kp_item_type_id);
            if (kp_copies == 0)
                continue;

            ItemPos copies = kp2orig[kp_item_type_id].second;

            for (ItemPos kp_copy = 0; kp_copy < kp_copies; ++kp_copy) {
                cut_position += kp_instance.item_type(kp_item_type_id).length
                    - cut_thickness;
                extra_solution_builder.add_node(2, cut_position);

                Length width_cur = 0;
                //std::cout << "copies " << copies << std::endl;
                if (copies == 1) {
                    width_cur += item_type.rect.w;
                    if (width_cur < width_max) {
                        //std::cout << "add_node depth 3 cut_position " << bin_type.left_trim + width_cur << std::endl;
                        extra_solution_builder.add_node(3, bin_type.left_trim + width_cur);
                    }
                    extra_solution_builder.set_last_node_item(item_type_id);
                } else {
                    for (ItemPos copy = 0; copy < copies; ++copy) {
                        width_cur += item_type.rect.w;
                        //std::cout << "add_node depth 3 cut_position " << bin_type.left_trim + width_cur << std::endl;
                        extra_solution_builder.add_node(3, bin_type.left_trim + width_cur);
                        extra_solution_builder.set_last_node_item(item_type_id);
                        width_cur += cut_thickness;
                    }
                }
                cut_position += cut_thickness;
            }
        }
        Solution extra_solution = extra_solution_builder.build();

        // Retrieve column.
        Column column = solution_to_column(extra_solution);
        output.columns.push_back(std::shared_ptr<const Column>(new Column(column)));
        if (instance_.parameters().number_of_stages == 3
                && instance_.parameters().cut_type == CutType::Homogenous
                && instance_.all_item_types_oriented()) {
            reduced_cost_bound = (std::max)(
                    reduced_cost_bound,
                    columngenerationsolver::compute_reduced_cost(column, duals));
        }

        // Find the largest width strictly smaller than the largest width
        // in the generated column.
        Length width_new = 0;
        for (ItemTypeId item_type_id = 0;
                item_type_id < instance_.number_of_item_types();
                ++item_type_id) {
            const ItemType& item_type = instance_.item_type(item_type_id);

            ItemPos copies = item_type.copies - filled_demands_[item_type_id];
            if (copies == 0)
                continue;

            Profit profit = 0;
            if (instance_.objective() == Objective::OpenDimensionX) {
                profit = duals[item_type_id];
            } else if (instance_.objective() == Objective::Knapsack) {
                profit = item_type.profit - duals[item_type_id] * multiplier_profit;
            }
            if (!strictly_greater(profit, 0.0))
                continue;

            ItemPos number_of_copies_in_full_strip = (width_max - 1 + cut_thickness)
                / (item_type.rect.w + cut_thickness);
            if (number_of_copies_in_full_strip == 0)
                continue;
            if (item_type.rect.h > height)
                continue;
            ItemPos number_of_full_strips = copies / number_of_copies_in_full_strip;
            ItemPos number_of_copies_in_last_strip = copies % number_of_copies_in_full_strip;
            Length width_cur = (number_of_full_strips > 0)?
                number_of_copies_in_full_strip * item_type.rect.w
                + (number_of_copies_in_full_strip - 1) * cut_thickness:
                number_of_copies_in_last_strip * item_type.rect.w
                + (number_of_copies_in_last_strip - 1) * cut_thickness;
            //std::cout << "wj " << item_type.rect.w
            //    << " copies " << copies
            //    << " number_of_copies_in_full_strip " << number_of_copies_in_full_strip
            //    << " number_of_full_strips " << number_of_full_strips
            //    << " number_of_copies_in_last_strip " << number_of_copies_in_last_strip
            //    << " wcur " << width_cur
            //    << std::endl;

            if (width_new < width_cur)
                width_new = width_cur;
        }
        if (width_new == 0)
            break;
        width = width_new;
    }
    //std::cout << "generate_2ho_patterns end" << std::endl;
}

void ColumnGenerationPricingSolver::generate_lower_stage_patterns(
        const std::vector<Value>& duals,
        PricingOutput& output,
        Value& reduced_cost_bound)
{
    // TODO
}

PricingOutput ColumnGenerationPricingSolver::solve_pricing(
            const std::vector<Value>& duals)
{
    //std::cout << "solve_pricing" << std::endl;

    const BinType& bin_type = instance_.bin_type(0);

    PricingOutput output;
    Value reduced_cost_bound = 0.0;

    // If all columns have already been generated, stop.

    if (instance_.parameters().number_of_stages == 1
            && instance_.parameters().cut_type == CutType::Roadef2018) {
        return output;
    }

    if (instance_.parameters().number_of_stages == 2
            && instance_.parameters().cut_type == CutType::Homogenous) {
        return output;
    }

    if (all_columns_2e_patterns_generated_
            && instance_.parameters().number_of_stages == 2
            && instance_.parameters().cut_type == CutType::Exact) {
        return output;
    }

    if (all_columns_2n_patterns_generated_
            && instance_.parameters().number_of_stages == 2
            && instance_.parameters().cut_type == CutType::NonExact) {
        return output;
    }

    if (all_columns_2r_patterns_generated_
            && instance_.parameters().number_of_stages == 2
            && instance_.parameters().cut_type == CutType::Roadef2018) {
        return output;
    }

    if (all_columns_3h_patterns_generated_
            && instance_.parameters().number_of_stages == 3
            && instance_.parameters().cut_type == CutType::Homogenous) {
        return output;
    }

    // Otherwise, solve the pricing sub-problems.

    // Base cases.

    // Generate one-staged exact patterns.
    if (!all_columns_2e_patterns_generated_) {
        if ((instance_.parameters().number_of_stages == 2
                    && instance_.parameters().cut_type == CutType::Exact)
                || (instance_.parameters().number_of_stages == 2
                    && instance_.parameters().cut_type == CutType::NonExact)
                || (instance_.parameters().number_of_stages == 2
                    && instance_.parameters().cut_type == CutType::Roadef2018)
                || instance_.parameters().number_of_stages >= 3) {
            generate_1e_patterns(duals, output, reduced_cost_bound);
        }
    }

    // Generate one-staged non-exact patterns.
    if (!all_columns_2n_patterns_generated_) {
        if ((instance_.parameters().number_of_stages == 2
                    && instance_.parameters().cut_type == CutType::NonExact)
                || (instance_.parameters().number_of_stages == 2
                    && instance_.parameters().cut_type == CutType::Roadef2018)
                || instance_.parameters().number_of_stages >= 3) {
            generate_1n_patterns(duals, output, reduced_cost_bound);
        }
    }

    // Generate one-staged roadef2018 oriented patterns.
    if (!all_columns_2r_patterns_generated_) {
        if (instance_.parameters().number_of_stages == 2
                && instance_.parameters().cut_type == CutType::Roadef2018
                && instance_.all_item_types_oriented()) {
            generate_1ro_patterns(duals, output, reduced_cost_bound);
        }
    }

    // Generate two-staged homogenous patterns without rotations.
    if (!all_columns_3h_patterns_generated_) {
        if (instance_.parameters().number_of_stages >= 3) {
            generate_2ho_patterns(duals, output, reduced_cost_bound);
        }
    }

    bool has_good_column = false;
    for (const auto& column: output.columns) {
        Value rc = columngenerationsolver::compute_reduced_cost(*column, duals);
        if (strictly_greater(rc, 0)) {
            has_good_column = true;
            break;
        }
    }

    // Recursion.

    // Generate other patterns.
    if (!has_good_column) {
        if ((instance_.parameters().number_of_stages == 2
                    && instance_.parameters().cut_type == CutType::Roadef2018
                    && !instance_.all_item_types_oriented())
                || (instance_.parameters().number_of_stages == 3
                    && instance_.parameters().cut_type == CutType::Homogenous
                    && !instance_.all_item_types_oriented())
                || (instance_.parameters().number_of_stages == 3
                    && instance_.parameters().cut_type == CutType::Exact)
                || (instance_.parameters().number_of_stages == 3
                    && instance_.parameters().cut_type == CutType::NonExact)
                || (instance_.parameters().number_of_stages == 3
                    && instance_.parameters().cut_type == CutType::Roadef2018)
                || (instance_.parameters().number_of_stages >= 4)) {
            generate_lower_stage_patterns(duals, output, reduced_cost_bound);
        }
    }

    //std::cout << "solve_pricing end" << std::endl;
    output.overcost = instance_.number_of_items() * reduced_cost_bound;
    //for (const auto& column: output.columns)
    //    std::cout << *column << std::endl;
    return output;
}

void column_generation_2_vertical(
        const Instance& instance,
        const ColumnGeneration2Parameters& parameters,
        AlgorithmFormatter& algorithm_formatter)
{
    GetModelOutput cgs_model = get_model(instance);
    columngenerationsolver::LimitedDiscrepancySearchParameters cgslds_parameters;
    for (const auto& column: cgs_model.column_pool)
        cgslds_parameters.column_pool.push_back(column);
    cgslds_parameters.verbosity_level = 0;
    cgslds_parameters.timer = parameters.timer;
    cgslds_parameters.timer.add_end_boolean(&algorithm_formatter.end_boolean());
    cgslds_parameters.internal_diving = 0;
    cgslds_parameters.dummy_column_objective_coefficient = 2;
    cgslds_parameters.automatic_stop = parameters.automatic_stop;
    cgslds_parameters.new_solution_callback = [&instance, &algorithm_formatter](
            const columngenerationsolver::Output& cgs_output)
    {
        const BinType& bin_type = instance.bin_type(0);
        const columngenerationsolver::LimitedDiscrepancySearchOutput& cgslds_output
            = static_cast<const columngenerationsolver::LimitedDiscrepancySearchOutput&>(cgs_output);
        if (cgslds_output.solution.feasible()) {
            //std::cout << "callback..." << std::endl;
            SolutionBuilder solution_builder(instance);
            solution_builder.add_bin(0, 1, CutOrientation::Vertical);
            Length offset = 0;
            for (const auto& pair: cgslds_output.solution.columns()) {
                //std::cout << "offset " << offset << std::endl;
                const Column& column = *(pair.first);
                BinPos value = std::round(pair.second);
                for (BinPos v = 0; v < value; ++v) {
                    const SolutionBin& bin = std::static_pointer_cast<Solution>(column.extra)->bin(0);
                    bool first = true;
                    Length w_max = 0;
                    for (const SolutionNode& node: bin.nodes) {
                        //std::cout << "node " << node << std::endl;
                        if (node.d <= 0)
                            continue;
                        if (node.d == 1) {
                            if (!first)
                                break;
                            first = false;
                            w_max = std::max(w_max, node.r - node.l);
                        }
                        if (node.d % 2 == 1) {
                            //std::cout << "add_node depth " << node.d << " cut_position " << offset + node.r << std::endl;
                            solution_builder.add_node(node.d, offset + node.r);
                        } else {
                            //std::cout << "add_node depth " << node.d << " cut_position " << node.t << std::endl;
                            solution_builder.add_node(node.d, node.t);
                        }
                        if (node.item_type_id >= 0)
                            solution_builder.set_last_node_item(node.item_type_id);
                    }
                    offset += w_max + instance.parameters().cut_thickness;
                }
            }
            Solution solution = solution_builder.build();
            std::stringstream ss;
            ss << "CGV n " << cgslds_output.number_of_nodes;
            algorithm_formatter.update_solution(solution, ss.str());
            //std::cout << "callback end" << std::endl;
        }
    };
    cgslds_parameters.new_bound_callback = [&instance, &algorithm_formatter](
            const columngenerationsolver::Output& cgs_output)
    {
        const columngenerationsolver::LimitedDiscrepancySearchOutput& cgslds_output
            = static_cast<const columngenerationsolver::LimitedDiscrepancySearchOutput&>(cgs_output);
        double multiplier_profit = largest_power_of_two_lesser_or_equal(instance.largest_item_profit());
        algorithm_formatter.update_knapsack_bound(cgslds_output.bound * multiplier_profit);
    };
    cgslds_parameters.column_generation_parameters.solver_name
        = parameters.linear_programming_solver_name;
    columngenerationsolver::limited_discrepancy_search(cgs_model.model, cgslds_parameters);
}

void column_generation_2_horizontal(
        const Instance& instance,
        const ColumnGeneration2Parameters& parameters,
        AlgorithmFormatter& algorithm_formatter)
{
    // Build flipped instance.
    InstanceFlipper instance_flippper(instance);
    const Instance& flipped_instance = instance_flippper.flipped_instance();

    ColumnGeneration2Parameters flipped_parameters = parameters;
    flipped_parameters.new_solution_callback = [
        &instance, &algorithm_formatter, &instance_flippper](
                const packingsolver::Output<Instance, Solution>& ps_output)
        {
            const ColumnGeneration2Output& flipped_output
                = static_cast<const ColumnGeneration2Output&>(ps_output);
            std::stringstream ss;
            ss << "CGH n ";
            //std::cout << "callback flipped" << std::endl;
            Solution solution = instance_flippper.unflip_solution(
                    flipped_output.solution_pool.best());
            algorithm_formatter.update_solution(
                    solution,
                    ss.str());
            algorithm_formatter.update_knapsack_bound(
                    flipped_output.knapsack_bound);
        };
    column_generation_2(
            flipped_instance,
            flipped_parameters);
}

}

const ColumnGeneration2Output packingsolver::rectangleguillotine::column_generation_2(
        const Instance& instance,
        const ColumnGeneration2Parameters& parameters)
{
    ColumnGeneration2Output output(instance);
    AlgorithmFormatter algorithm_formatter(instance, parameters, output);
    algorithm_formatter.start();
    algorithm_formatter.print_header();

    // Reduction.
    if (instance.parameters().first_stage_orientation == CutOrientation::Vertical) {
        column_generation_2_vertical(
                instance,
                parameters,
                algorithm_formatter);
    } else if (instance.parameters().first_stage_orientation == CutOrientation::Horizontal) {
        column_generation_2_horizontal(
                instance,
                parameters,
                algorithm_formatter);
    } else {
        std::vector<std::thread> threads;
        std::forward_list<std::exception_ptr> exception_ptr_list;
        exception_ptr_list.push_front(std::exception_ptr());
        threads.push_back(std::thread(
                    wrapper<decltype(&column_generation_2_vertical), column_generation_2_vertical>,
                    std::ref(exception_ptr_list.front()),
                    std::ref(instance),
                    std::ref(parameters),
                    std::ref(algorithm_formatter)));
        threads.push_back(std::thread(
                    wrapper<decltype(&column_generation_2_horizontal), column_generation_2_horizontal>,
                    std::ref(exception_ptr_list.front()),
                    std::ref(instance),
                    std::ref(parameters),
                    std::ref(algorithm_formatter)));
        for (Counter i = 0; i < (Counter)threads.size(); ++i)
            threads[i].join();
        for (std::exception_ptr exception_ptr: exception_ptr_list)
            if (exception_ptr)
                std::rethrow_exception(exception_ptr);
    }

    algorithm_formatter.end();
    return output;
}
